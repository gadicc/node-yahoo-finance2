import { walk } from "@std/fs";
import { debounce } from "jsr:@std/async/debounce";

import {
  type Config,
  createFormatter,
  createParser,
  createProgram,
  SchemaGenerator,
} from "ts-json-schema-generator";

// @ts-expect-error: no types
import schemaWalker from "oas-schema-walker";
import walkerCallback from "./schema/postWalker.js";

import yfNumberTypeFormatter from "./schema/TypeFormatter/yfNumberTypeFormatter.ts";
import yfReferenceTypeFormatter from "./schema/TypeFormatter/yfReferenceTypeFormatter.ts";
import yfFunctionIgnorer from "./schema/TypeFormatter/yfFunctionIgnorer.ts";

const relevant = /@yf-schema/;

function createSchema(path: string) {
  const encoder = new TextEncoder();
  const outputPath = path.replace(/\.ts$/, ".schema.json");

  // Convenience for creating the file if it doesn't exist, so that import
  // won't fail on first time running ts-schema-gen on the file (later we'll
  // overwrite it with the actual generated schema)
  try {
    Deno.lstatSync(outputPath);
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    Deno.writeFileSync(outputPath, encoder.encode("{}"));
  }

  const config: Config = {
    path,
    tsconfig: "scripts/schema-tsconfig.json",
    type: "*",
  };

  const formatter = createFormatter(
    config,
    (chainTypeFormatter, circularReferenceTypeFormatter) => {
      chainTypeFormatter
        .addTypeFormatter(
          new yfReferenceTypeFormatter(
            circularReferenceTypeFormatter,
            config.encodeRefs ?? true,
          ),
        )
        .addTypeFormatter(new yfNumberTypeFormatter())
        .addTypeFormatter(new yfFunctionIgnorer());
    },
  );

  let program: ReturnType<typeof createProgram>;
  try {
    program = createProgram(config);
  } catch (error) {
    if (error instanceof Error) {
      console.log(error.message);
    } else {
      console.log(error);
    }
    console.log(`(still watching ${path}...)`);
    return;
  }

  const parser = createParser(program, config);
  const generator = new SchemaGenerator(program, parser, formatter, config);

  let _schema: ReturnType<typeof generator.createSchema>;
  try {
    _schema = generator.createSchema(config.type);
  } catch (error) {
    if (error instanceof Error) {
      console.log(error.message);
    } else {
      console.log(error);
    }
    console.log(`(still watching ${path}...)`);
    return;
  }

  const schema = {
    $schema: _schema!.$schema,
    $comment: "DO NOT EDIT THIS FILE.  It is generated automatically " +
      "from typescript interfaces in the project.  To update, run " +
      "`deno task schema`.",
    ..._schema!,
  };

  // @ts-expect-error: no types
  for (const key of Object.keys(schema.definitions)) {
    // @ts-expect-error: no types
    schemaWalker.walkSchema(schema.definitions[key], {}, {}, walkerCallback);
  }

  const schemaString = JSON.stringify(schema, null, 2);

  const encoded = encoder.encode(schemaString);
  Deno.writeFileSync(outputPath, encoded);
}

async function check(path: string) {
  const file = await Deno.readTextFile(path);
  // TODO, file stat
  if (relevant.test(file)) {
    console.log("Creating schema for " + path);
    createSchema(path);
  }
}

const debouncedCheck = debounce(check, 1000);

if (true) {
  const watcher = Deno.watchFs("src");

  /*
  Deno.addSignalListener("SIGINT", () => {
    // watcher.close();
    Deno.exit();
  });
  */

  (async () => {
    for await (const event of watcher) {
      if (event.kind === "modify") {
        debouncedCheck(event.paths[0]);
      }
    }
  })();
}

for await (const entry of walk("src", { exts: [".ts"] })) {
  check(entry.path);
}
