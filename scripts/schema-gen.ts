import { walk } from "@std/fs";
import { debounce } from "@std/async/debounce";
import { parseArgs } from "@std/cli/parse-args";

import {
  type Config,
  createFormatter,
  createParser,
  createProgram,
  SchemaGenerator,
} from "ts-json-schema-generator";

// @ts-expect-error: no types
import schemaWalker from "oas-schema-walker";
import walkerCallback from "./schema/postWalker.js";

import yfNumberTypeFormatter from "./schema/TypeFormatter/yfNumberTypeFormatter.ts";
import yfReferenceTypeFormatter from "./schema/TypeFormatter/yfReferenceTypeFormatter.ts";
import yfFunctionIgnorer from "./schema/TypeFormatter/yfFunctionIgnorer.ts";

// TODO, we should also lstat this file and all it's imports!

const relevant = /@yf-schema/;

function createSchema(path: string, force = false) {
  const encoder = new TextEncoder();
  const outputPath = path.replace(/\.ts$/, ".schema.json");

  const inputStat = Deno.lstatSync(path);
  let outputStat: Deno.FileInfo | undefined;

  // Convenience for creating the file if it doesn't exist, so that import
  // won't fail on first time running ts-schema-gen on the file (later we'll
  // overwrite it with the actual generated schema)
  try {
    outputStat = Deno.lstatSync(outputPath);
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    Deno.writeFileSync(outputPath, encoder.encode("{}"));
  }

  if (!force && outputStat && inputStat.mtime! < outputStat.mtime!) {
    console.log("* " + path + ": skipping unchanged file.");
    return;
  }

  console.log("* " + path + ": creating schema...");

  const config: Config = {
    path,
    tsconfig: "scripts/schema-tsconfig.json",
    type: "*",
  };

  const formatter = createFormatter(
    config,
    (chainTypeFormatter, circularReferenceTypeFormatter) => {
      chainTypeFormatter
        .addTypeFormatter(
          new yfReferenceTypeFormatter(
            circularReferenceTypeFormatter,
            config.encodeRefs ?? true,
          ),
        )
        .addTypeFormatter(new yfNumberTypeFormatter())
        .addTypeFormatter(new yfFunctionIgnorer());
    },
  );

  let program: ReturnType<typeof createProgram>;
  try {
    program = createProgram(config);
  } catch (error) {
    if (error instanceof Error) {
      console.log(error.message);
    } else {
      console.log(error);
    }
    // TODO, only log this if in watch mode
    console.log(`(still watching ${path}...)`);
    return;
  }

  const parser = createParser(program, config);
  const generator = new SchemaGenerator(program, parser, formatter, config);

  let _schema: ReturnType<typeof generator.createSchema>;
  try {
    _schema = generator.createSchema(config.type);
  } catch (error) {
    if (error instanceof Error) {
      console.log(error.message);
    } else {
      console.log(error);
    }
    console.log(`(still watching ${path}...)`);
    return;
  }

  const schema = {
    $schema: _schema!.$schema,
    $comment: "DO NOT EDIT THIS FILE.  It is generated automatically " +
      "from typescript interfaces in the project.  To update, run " +
      "`deno task schema` (with optional `--watch`).  In VSCode, this " +
      "is run automatically for you on folder open.",
    ..._schema!,
  };

  // @ts-expect-error: no types
  for (const key of Object.keys(schema.definitions)) {
    // @ts-expect-error: no types
    schemaWalker.walkSchema(schema.definitions[key], {}, {}, walkerCallback);
  }

  const schemaString = JSON.stringify(schema, null, 2);

  const encoded = encoder.encode(schemaString);
  Deno.writeFileSync(outputPath, encoded);
}

async function check(path: string, force = false) {
  const file = await Deno.readTextFile(path);
  if (relevant.test(file)) {
    createSchema(path, force);
  }
}

const debouncedCheck = debounce(check, 1000);

const flags = parseArgs(Deno.args, {
  boolean: ["watch", "force", "help"],
  default: { watch: false, force: false, help: false },
  negatable: ["watch", "force", "help"],
  alias: { w: "watch", f: "force", h: "help" },
});

if (flags.help) {
  console.log(`
Usage
  $ deno task schema [options]

Options
  -h, --help    Show this help
  -w, --watch   Watch for changes
  -f, --force   Force update of all schemas
`);
  Deno.exit();
}

console.log('Scanning project for .ts files containing "@yf-schema"...');
console.log();
for await (const entry of walk("src", { exts: [".ts"] })) {
  check(entry.path, flags.force);
}
console.log();
console.log("Scan complete.");

if (flags.watch) {
  console.log();
  console.log("Watching `src` for changes (Ctrl-C to exit)...");
  console.log();
  const watcher = Deno.watchFs("src");

  /*
  Deno.addSignalListener("SIGINT", () => {
    // watcher.close();
    Deno.exit();
  });
  */

  (async () => {
    for await (const event of watcher) {
      if (event.kind === "modify") {
        debouncedCheck(event.paths[0]);
      }
    }
  })();
}
